<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Meditative Breathing App</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #f0f4f8;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      margin: 0;
    }
    .controls {
      margin-bottom: 30px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      width: 100%;
      max-width: 350px;
    }
    .controls label {
      font-weight: bold;
      margin-bottom: 2px;
    }
    .control-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }
    .button-group {
      display: flex;
      flex-direction: column;
      gap: 12px;
      width: 100%;
      max-width: 350px;
      margin-bottom: 10px;
    }
    button {
      font-size: 1em;
      padding: 12px 0;
      border: none;
      border-radius: 5px;
      background: #4a90e2;
      color: #fff;
      cursor: pointer;
      transition: background 0.2s;
      width: 100%;
    }
    button:disabled {
      background: #b0c4de;
      cursor: not-allowed;
    }
    button:hover:not(:disabled) {
      background: #357ab8;
    }
    @media (min-width: 500px) {
      .controls {
        flex-direction: row;
        flex-wrap: wrap;
        gap: 20px;
        max-width: 700px;
      }
      .control-row {
        flex-direction: row;
        width: auto;
      }
      .button-group {
        flex-direction: row;
        gap: 16px;
        max-width: 700px;
      }
      button {
        width: auto;
        min-width: 90px;
        margin: 0;
      }
    }
    .timer {
      font-size: 2em;
      margin-bottom: 20px;
    }
    .triangle-container {
      position: relative;
      width: 300px;
      height: 260px;
      margin-bottom: 30px;
    }
    svg {
      position: absolute;
      top: 0;
      left: 0;
    }
    .ball {
      position: absolute;
      width: 30px;
      height: 30px;
      border-radius: 50%;
      background: #4a90e2;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      transition: left 0.5s linear, top 0.5s linear;
    }
    .phase-label {
      text-align: center;
      font-size: 1.2em;
      margin-bottom: 10px;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <div class="controls">
    <div class="control-row">
      <label for="type">Type</label>
      <select id="type">
        <option value="478">4-7-8</option>
        <option value="box">Box Breathing</option>
      </select>
    </div>
    <div class="control-row">
      <label for="inhale">Inhale</label>
      <select id="inhale"></select>
      <span>sec</span>
    </div>
    <div class="control-row" id="hold1-row">
      <label for="hold">Hold</label>
      <select id="hold"></select>
      <span>sec</span>
    </div>
    <div class="control-row">
      <label for="exhale">Exhale</label>
      <select id="exhale"></select>
      <span>sec</span>
    </div>
    <div class="control-row" id="hold2-row" style="display:none">
      <label for="hold2">Hold</label>
      <select id="hold2"></select>
      <span>sec</span>
    </div>
    <div class="control-row">
      <label for="timer">Timer</label>
      <select id="timer"></select>
      <span>min</span>
    </div>
  </div>
  <div class="timer" id="main-timer">05:00</div>
  <div class="phase-label" id="phase-label">Ready</div>
  <div class="triangle-container" id="shape-container">
    <svg id="shape-svg" width="300" height="260">
      <polygon id="shape-polygon" points="150,20 280,240 20,240" fill="none" stroke="#333" stroke-width="3" />
    </svg>
    <div class="ball" id="ball" style="left: 135px; top: 210px;"></div>
  </div>
  <div class="button-group">
    <button id="start">Start</button>
    <button id="pause" disabled>Pause</button>
    <button id="resume" disabled>Resume</button>
    <button id="stop" disabled>Stop</button>
  </div>
  <audio id="silent-audio" loop style="display:none">
    <source src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQAAAAA=" type="audio/wav">
  </audio>
  <script>
    // Populate dropdowns
    function populateSelect(id, min, max, selected) {
      const sel = document.getElementById(id);
      for (let i = min; i <= max; i++) {
        const opt = document.createElement('option');
        opt.value = i;
        opt.textContent = i;
        if (i === selected) opt.selected = true;
        sel.appendChild(opt);
      }
    }
    populateSelect('inhale', 0, 60, 4);
    populateSelect('hold', 0, 60, 7);
    populateSelect('exhale', 0, 60, 8);
    populateSelect('timer', 0, 60, 5);
    // Add Hold2 dropdown
    populateSelect('hold2', 0, 60, 4);

    // Triangle points
    const A = {x: 150, y: 20}; // top
    const B = {x: 280, y: 240}; // right
    const C = {x: 20, y: 240}; // left
    const ball = document.getElementById('ball');
    const phaseLabel = document.getElementById('phase-label');
    const mainTimer = document.getElementById('main-timer');
    // Web Audio API context for bell sounds
    let audioCtx = null;
    function getAudioCtx() {
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
      return audioCtx;
    }
    // Continuous tone generator for each phase
    let phaseOsc = null, phaseGain = null;
    function playContinuousTone(frequency = 440) {
      stopAllSounds();
      const ctx = getAudioCtx();
      const now = ctx.currentTime;
      phaseOsc = ctx.createOscillator();
      phaseOsc.type = 'triangle'; // Smoother than sine for meditation
      phaseOsc.frequency.value = frequency;
      phaseGain = ctx.createGain();
      phaseGain.gain.setValueAtTime(0, now);
      phaseGain.gain.linearRampToValueAtTime(0.12, now + 0.5); // slower, softer fade in
      phaseOsc.connect(phaseGain);
      phaseGain.connect(ctx.destination);
      phaseOsc.start(now);
    }
    function stopAllSounds() {
      if (phaseOsc) {
        try {
          const ctx = getAudioCtx();
          const now = ctx.currentTime;
          phaseGain.gain.cancelScheduledValues(now);
          phaseGain.gain.setValueAtTime(phaseGain.gain.value, now);
          phaseGain.gain.linearRampToValueAtTime(0.0001, now + 0.7); // slower fade out
          phaseOsc.stop(now + 0.7);
        } catch (e) {}
        phaseOsc = null;
        phaseGain = null;
      }
    }
    let inhaleSec = 4, holdSec = 7, exhaleSec = 8, totalMin = 5;
    let timerInterval = null, phaseTimeout = null, totalTimeLeft = 0, running = false, paused = false;
    let phase = 0, phaseOrder = [], phaseNames = [];
    let ballAnimFrame = null, phaseStartTime = 0, phaseDuration = 0;
    function updateSettings() {
      inhaleSec = parseInt(document.getElementById('inhale').value);
      holdSec = parseInt(document.getElementById('hold').value);
      exhaleSec = parseInt(document.getElementById('exhale').value);
      totalMin = parseInt(document.getElementById('timer').value);
    }
    function formatTime(sec) {
      const m = Math.floor(sec / 60);
      const s = sec % 60;
      return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
    }
    function setBall(pos) {
      // pos: 0=start (C), 1=top (A), 2=right (B), 3=left (C)
      let x, y;
      if (pos === 0) { x = C.x; y = C.y; }
      else if (pos === 1) { x = A.x; y = A.y; }
      else if (pos === 2) { x = B.x; y = B.y; }
      else { x = C.x; y = C.y; }
      ball.style.left = (x - 15) + 'px';
      ball.style.top = (y - 15) + 'px';
    }
    function animateBall(from, to, duration, onDone) {
      const start = {...from};
      const end = {...to};
      const startTime = performance.now();
      function step(now) {
        let elapsed = now - startTime;
        let t = Math.min(elapsed / (duration * 1000), 1);
        let x = start.x + (end.x - start.x) * t;
        let y = start.y + (end.y - start.y) * t;
        ball.style.left = (x - 15) + 'px';
        ball.style.top = (y - 15) + 'px';
        if (t < 1 && running && !paused) {
          ballAnimFrame = requestAnimationFrame(step);
        } else {
          if (onDone) onDone();
        }
      }
      ballAnimFrame = requestAnimationFrame(step);
    }
    function stopBallAnimation() {
      if (ballAnimFrame) cancelAnimationFrame(ballAnimFrame);
    }
    function playSound(phaseName) {
      if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
      if (phaseName === 'Inhale') playContinuousTone(523.25); // C5
      else if (phaseName === 'Hold') playContinuousTone(659.25); // E5
      else if (phaseName === 'Exhale') playContinuousTone(392.00); // G4
    }
    // Type switching logic
    const typeSelect = document.getElementById('type');
    const hold1Row = document.getElementById('hold1-row');
    const hold2Row = document.getElementById('hold2-row');
    const shapeSvg = document.getElementById('shape-svg');
    const shapePolygon = document.getElementById('shape-polygon');
    let boxMode = false;
    typeSelect.onchange = function() {
      if (typeSelect.value === 'box') {
        hold2Row.style.display = '';
        hold1Row.querySelector('label').textContent = 'Hold';
        boxMode = true;
        // Draw square
        shapePolygon.setAttribute('points', '40,40 260,40 260,220 40,220');
        // Set ball to square start position
        setBallSquare(0, {x:40,y:220}, {x:40,y:40}, {x:260,y:40}, {x:260,y:220});
      } else {
        hold2Row.style.display = 'none';
        hold1Row.querySelector('label').textContent = 'Hold';
        boxMode = false;
        // Draw triangle
        shapePolygon.setAttribute('points', '150,20 280,240 20,240');
        // Set ball to triangle start position
        setBall(0);
      }
      setInitialDurations();
    };
    function setInitialDurations() {
      if (typeSelect.value === 'box') {
        document.getElementById('inhale').value = 4;
        document.getElementById('hold').value = 4;
        document.getElementById('exhale').value = 4;
        document.getElementById('hold2').value = 4;
      } else {
        document.getElementById('inhale').value = 4;
        document.getElementById('hold').value = 7;
        document.getElementById('exhale').value = 8;
      }
    }
    // Set initial durations on load
    setInitialDurations();
    function startBreathCycle() {
      phaseOrder = [];
      phaseNames = [];
      if (typeSelect.value === 'box') {
        // Square: Inhale (left->top), Hold1 (top->right), Exhale (right->bottom), Hold2 (bottom->left)
        const S1 = {x: 40, y: 220}; // bottom-left
        const S2 = {x: 40, y: 40};  // top-left
        const S3 = {x: 260, y: 40}; // top-right
        const S4 = {x: 260, y: 220}; // bottom-right
        let inhale = parseInt(document.getElementById('inhale').value);
        let hold1 = parseInt(document.getElementById('hold').value);
        let exhale = parseInt(document.getElementById('exhale').value);
        let hold2 = parseInt(document.getElementById('hold2').value);
        if (inhale > 0) { phaseOrder.push([S1, S2, inhale]); phaseNames.push('Inhale'); }
        if (hold1 > 0) { phaseOrder.push([S2, S3, hold1]); phaseNames.push('Hold'); }
        if (exhale > 0) { phaseOrder.push([S3, S4, exhale]); phaseNames.push('Exhale'); }
        if (hold2 > 0) { phaseOrder.push([S4, S1, hold2]); phaseNames.push('Hold'); }
        setBallSquare(0, S1, S2, S3, S4);
      } else {
        // Triangle: Inhale (C->A), Hold (A->B), Exhale (B->C)
        if (inhaleSec > 0) { phaseOrder.push([C, A, inhaleSec]); phaseNames.push('Inhale'); }
        if (holdSec > 0) { phaseOrder.push([A, B, holdSec]); phaseNames.push('Hold'); }
        if (exhaleSec > 0) { phaseOrder.push([B, C, exhaleSec]); phaseNames.push('Exhale'); }
        setBall(0);
      }
      phase = 0;
      nextPhase();
    }
    // Helper for square: set ball to start
    function setBallSquare(pos, S1, S2, S3, S4) {
      // pos: 0=start (S1), 1=S2, 2=S3, 3=S4
      let x, y;
      if (pos === 0) { x = S1.x; y = S1.y; }
      else if (pos === 1) { x = S2.x; y = S2.y; }
      else if (pos === 2) { x = S3.x; y = S3.y; }
      else if (pos === 3) { x = S4.x; y = S4.y; }
      else { x = S1.x; y = S1.y; }
      ball.style.left = (x - 15) + 'px';
      ball.style.top = (y - 15) + 'px';
    }
    function nextPhase() {
      if (!running || paused) return;
      if (phase >= phaseOrder.length) phase = 0;
      const [from, to, duration] = phaseOrder[phase];
      const phaseName = phaseNames[phase];
      phaseLabel.textContent = phaseName;
      playSound(phaseName);
      phaseStartTime = Date.now();
      phaseDuration = duration;
      animateBall(from, to, duration, () => {
        if (running && !paused) {
          phase++;
          nextPhase();
        }
      });
      phaseTimeout = setTimeout(() => {
        // nothing, handled by animation
      }, duration * 1000);
    }
    function stopBreathCycle() {
      stopBallAnimation();
      stopAllSounds();
      if (phaseTimeout) clearTimeout(phaseTimeout);
      setBall(0);
      phaseLabel.textContent = 'Ready';
    }
    function startTimer() {
      totalTimeLeft = totalMin * 60;
      mainTimer.textContent = formatTime(totalTimeLeft);
      timerInterval = setInterval(() => {
        if (!paused && running) {
          totalTimeLeft--;
          mainTimer.textContent = formatTime(totalTimeLeft);
          if (totalTimeLeft <= 0) {
            stopAll();
          }
        }
      }, 1000);
    }
    function stopTimer() {
      if (timerInterval) clearInterval(timerInterval);
      mainTimer.textContent = formatTime(totalMin * 60);
    }
    // Wake Lock and iOS fallback
    let wakeLock = null;
    const silentAudio = document.getElementById('silent-audio');
    async function requestWakeLock() {
      if ('wakeLock' in navigator) {
        try {
          wakeLock = await navigator.wakeLock.request('screen');
        } catch (e) {
          // fallback below
        }
      }
      // iOS fallback: play silent audio
      if (silentAudio && silentAudio.paused) {
        try { silentAudio.play(); } catch (e) {}
      }
    }
    async function releaseWakeLock() {
      if (wakeLock) {
        try { await wakeLock.release(); } catch (e) {}
        wakeLock = null;
      }
      if (silentAudio && !silentAudio.paused) {
        try { silentAudio.pause(); silentAudio.currentTime = 0; } catch (e) {}
      }
    }
    function stopAll() {
      running = false;
      paused = false;
      stopTimer();
      stopBreathCycle();
      releaseWakeLock();
      document.getElementById('start').disabled = false;
      document.getElementById('pause').disabled = true;
      document.getElementById('resume').disabled = true;
      document.getElementById('stop').disabled = true;
    }
    document.getElementById('start').onclick = function() {
      updateSettings();
      if (inhaleSec === 0 && holdSec === 0 && exhaleSec === 0) return;
      running = true;
      paused = false;
      document.getElementById('start').disabled = true;
      document.getElementById('pause').disabled = false;
      document.getElementById('resume').disabled = true;
      document.getElementById('stop').disabled = false;
      setBall(0);
      requestWakeLock();
      startBreathCycle();
      if (totalMin > 0) startTimer();
      else mainTimer.textContent = '00:00';
    };
    document.getElementById('pause').onclick = function() {
      if (!running || paused) return;
      paused = true;
      stopBallAnimation();
      stopAllSounds();
      document.getElementById('pause').disabled = true;
      document.getElementById('resume').disabled = false;
    };
    document.getElementById('resume').onclick = function() {
      if (!running || !paused) return;
      paused = false;
      document.getElementById('pause').disabled = false;
      document.getElementById('resume').disabled = true;
      // Resume current phase
      const [from, to, duration] = phaseOrder[phase];
      // Calculate time left in phase
      let elapsed = (Date.now() - phaseStartTime) / 1000;
      let timeLeft = Math.max(phaseDuration - elapsed, 0.1);
      animateBall(ballPosition(), to, timeLeft, () => {
        if (running && !paused) {
          phase++;
          nextPhase();
        }
      });
      playSound(phaseNames[phase]);
    };
    document.getElementById('stop').onclick = function() {
      stopAll();
    };
    function ballPosition() {
      // Get current ball position
      const left = parseFloat(ball.style.left) + 15;
      const top = parseFloat(ball.style.top) + 15;
      return {x: left, y: top};
    }
    // Set initial ball position
    setBall(0);
    mainTimer.textContent = formatTime(5 * 60);
  </script>
</body>
</html>
